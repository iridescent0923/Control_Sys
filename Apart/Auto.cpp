///////////////////////////////////////////////////////////////////////////////
// Auto.cpp
#include "TcPch.h"
#pragma hdrstop

#include "Auto.h"

#define PI 3.14159265358979323846264
#define R2D 180.0/PI
#define D2R PI/180.0
#define C2R (2*PI)/(4*65536.0)

#define V2C 32767.0/10.0


#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CAuto
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CAuto
BEGIN_INTERFACE_MAP(CAuto)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()


IMPLEMENT_ITCOMOBJECT(CAuto)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CAuto)
IMPLEMENT_ITCADI(CAuto)
IMPLEMENT_ITCWATCHSOURCE(CAuto)


///////////////////////////////////////////////////////////////////////////////
// Set parameters of CAuto 
BEGIN_SETOBJPARA_MAP(CAuto)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_AutoParameter, m_Parameter)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CAuto 
BEGIN_GETOBJPARA_MAP(CAuto)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_AutoParameter, m_Parameter)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CAuto
BEGIN_OBJPARAWATCH_MAP(CAuto)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CAuto
BEGIN_OBJDATAAREA_MAP(CAuto)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_AutoInputs, m_Inputs)
	OBJDATAAREA_VALUE(ADI_AutoOutputs, m_Outputs)
	OBJDATAAREA_VALUE(ADI_AutoEncoder, m_Encoder)
	OBJDATAAREA_VALUE(ADI_AutoControl, m_Control)
	OBJDATAAREA_VALUE(ADI_AutoTrajecory, m_Trajecory)
	OBJDATAAREA_VALUE(ADI_AutoSafe, m_Safe)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CAuto::CAuto()
	: m_Trace(m_TraceLevelMax, m_spSrv)
	, m_counter(0)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	memset(&m_Parameter, 0, sizeof(m_Parameter));
	memset(&m_Inputs, 0, sizeof(m_Inputs));
	memset(&m_Outputs, 0, sizeof(m_Outputs));
	memset(&m_Encoder, 0, sizeof(m_Encoder));
	memset(&m_Control, 0, sizeof(m_Control));
	memset(&m_Trajecory, 0, sizeof(m_Trajecory));
	memset(&m_Safe, 0, sizeof(m_Safe));
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
CAuto::~CAuto() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CAuto)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CAuto::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	// TODO: Add initialization code

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CAuto::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Add any additional initialization


	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CAuto::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	RemoveModuleFromCaller(); 

	// TODO: Add any additional deinitialization

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CAuto::SetObjStateSP()
{
	HRESULT hr = S_OK;
	m_Trace.Log(tlVerbose, FENTERA);

	// TODO: Add deinitialization code

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CAuto::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	// TODO: Replace the sample with your cyclic code
	
	if (m_Safe.SW == false)
	{
		init();
	}
	else
	{
		readEnc();
		

		if (t <= 10.0)
		{
			//m_Control.Voltage = sin_(w * t);

			//m_Control.Angle_Des = 0.05;
			//m_Control.AngVel_Des = 0.0;
			
			
			//m_Control.Angle_Des = m_Trajecory.a[0] + m_Trajecory.a[1] * t + m_Trajecory.a[2] * t * t + m_Trajecory.a[3] * t * t * t;
			//m_Control.AngVel_Des = m_Trajecory.a[1] + m_Trajecory.a[2] * t + m_Trajecory.a[3] * t * t;
			m_Control.Angle_Des = m_Trajecory.a[2] * t * t + m_Trajecory.a[3] * t * t * t;
			m_Control.AngVel_Des = 2 * m_Trajecory.a[2] * t + 3 * m_Trajecory.a[3] * t * t;

			PID_Control();
		}
		else
			m_Control.Voltage = 0.0;

		
		t += 0.001;
	}

	m_Outputs.VolCnt = int((5 + m_Control.Voltage) * V2C);
	return hr;
}
///</AutoGeneratedContent>
void CAuto::init(void)
{
	m_Control.Voltage = 0.0;

	m_Encoder.EncRaw_current = m_Inputs.EncRawIN;
	m_Encoder.EncRaw_pre = m_Encoder.EncRaw_current;
	m_Encoder.Enc_diff = m_Encoder.EncRaw_current - m_Encoder.EncRaw_pre;
	m_Encoder.Angle = 0;

	m_Encoder.Angle_current = m_Encoder.Angle;
	m_Encoder.Angle_pre = m_Encoder.Angle_current;
	m_Encoder.AngVel = 0;

	t = 0;
	w = 1.0;

	Kp = 0.9*5;
	Ki = 0.02*5;
	Kd = 0.05*5;
	m_Trajecory.a[0] = 0;
	m_Trajecory.a[1] = 0;
	m_Trajecory.a[2] = 1.8;
	m_Trajecory.a[3] = -0.12;
	m_Trajecory.a[4] = 0;
	m_Trajecory.a[5] = 0;

}

void CAuto::readEnc(void)
{
	m_Encoder.EncRaw_current = m_Inputs.EncRawIN;
	m_Encoder.Enc_diff = m_Encoder.EncRaw_current - m_Encoder.EncRaw_pre;

	if (m_Encoder.Enc_diff < -40000)
	{
		m_Encoder.Enc_diff = (65536 - m_Encoder.EncRaw_pre) + m_Encoder.EncRaw_current;
	}
	else if (m_Encoder.Enc_diff > 40000)
	{
		m_Encoder.Enc_diff = (m_Encoder.EncRaw_current - 65536) - m_Encoder.EncRaw_pre;
	}
	m_Encoder.Angle -= (double)m_Encoder.Enc_diff * C2R;

	m_Encoder.Angle_current = m_Encoder.Angle;
	m_Encoder.AngVel = (m_Encoder.Angle_current - m_Encoder.Angle_pre) / 0.001;

	m_Encoder.Angle_pre = m_Encoder.Angle_current;
	m_Encoder.EncRaw_pre = m_Encoder.EncRaw_current;

}

void CAuto::PID_Control(void)
{
	m_Control.Angle_Err = m_Control.Angle_Des - m_Encoder.Angle;
	m_Control.AngVel_Err = m_Control.AngVel_Des - m_Encoder.AngVel;
	m_Control.Angle_ErrInt += m_Control.Angle_Err * 0.001;

	m_Control.Voltage = Kp * m_Control.Angle_Err + Ki * m_Control.Angle_ErrInt + Kd * m_Control.AngVel_Err;

	
	if (m_Control.Voltage < 0.20 && m_Control.Voltage > 0)
		m_Control.Voltage += 0.1;
	else if (m_Control.Voltage > -0.20 && m_Control.Voltage < 0)
		m_Control.Voltage -= 0.1;
	
}


///////////////////////////////////////////////////////////////////////////////
HRESULT CAuto::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CAuto::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;

	m_Trace.Log(tlVerbose, FLEAVEA);
}

